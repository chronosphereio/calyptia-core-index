{
  "processingRules": {
    "aggregate": {
      "description": "Transform incoming logs into computed metrics at periodic intervals.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "compute": {
            "additionalProperties": {
              "prefixItems": [
                {
                  "type": "string"
                },
                {
                  "type": "string"
                }
              ],
              "type": "array"
            },
            "description": "Additional keys which will be computed for each group",
            "type": "object"
          },
          "keys": {
            "description": "Keys which will be used for grouping",
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "prefixItems": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "type": "array"
                }
              ]
            },
            "type": "array"
          },
          "window": {
            "description": "Time window in seconds",
            "type": "integer"
          }
        },
        "required": [
          "keys",
          "window",
          "compute"
        ],
        "type": "object"
      },
      "label": "Aggregate records",
      "uiSchema": {
        "labels": {
          "compute": "Compute keys",
          "keys": "Select keys",
          "window": "Time window"
        },
        "ordering": [
          "window",
          "keys",
          "compute"
        ]
      }
    },
    "allow_keys": {
      "description": "Preserve any keys that match a specified regular expression, and remove all other keys.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "matchCase": {
            "default": false,
            "description": "Flag which controls if the regex match will be case-sensitive",
            "type": "boolean"
          },
          "nestedPath": {
            "default": "",
            "description": "Nested access pattern",
            "type": "string"
          },
          "regex": {
            "description": "Regular expression that will be used match allowed keys",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          }
        },
        "required": [
          "regex"
        ],
        "type": "object"
      },
      "label": "Allow keys"
    },
    "allow_records": {
      "description": "Preserve any records that contain a key whose value matches a specified regular expression, and remove all other records.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "default": "log",
            "description": "Key that will be checked",
            "type": "string"
          },
          "matchCase": {
            "default": false,
            "description": "Flag which controls if the regex match will be case-sensitive",
            "type": "boolean"
          },
          "regex": {
            "description": "Regular expression that will be used match the key",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          }
        },
        "required": [
          "regex"
        ],
        "type": "object"
      },
      "label": "Allow records"
    },
    "block_keys": {
      "description": "Remove any keys that match a specified regular expression, and preserve all other keys.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "matchCase": {
            "default": false,
            "description": "Flag which controls if the regex match will be case-sensitive",
            "type": "boolean"
          },
          "nestedPath": {
            "default": "",
            "description": "Nested access pattern",
            "type": "string"
          },
          "regex": {
            "description": "Regular expression that will be used match blocked keys",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          }
        },
        "required": [
          "regex"
        ],
        "type": "object"
      },
      "label": "Block keys"
    },
    "block_records": {
      "description": "Remove any records that contain a key whose value matches a specified regular expression, and preserve all other records.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "default": "log",
            "description": "Key that will be checked",
            "type": "string"
          },
          "matchCase": {
            "default": false,
            "description": "Flag which controls if the regex match will be case-sensitive",
            "type": "boolean"
          },
          "regex": {
            "description": "Regular expression that will be used match the key",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          }
        },
        "required": [
          "regex"
        ],
        "type": "object"
      },
      "label": "Block records"
    },
    "copy": {
      "description": "Copy the value of a specified source key to the value of a specified destination key.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "dst": {
            "description": "Destination key to which the value will be copied to. If `regexMode` is true, this can reference captured groups.",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          },
          "regexMode": {
            "default": false,
            "description": "If set, `src` will be treated as a regex and `dst` as a substitution pattern.",
            "type": "boolean"
          },
          "src": {
            "description": "Source key from which the value will be copied from. If `regexMode` is true, this can match multiple keys.",
            "type": "string"
          }
        },
        "required": [
          "dst",
          "src"
        ],
        "type": "object"
      },
      "label": "Copy keys"
    },
    "csv_decode": {
      "description": "Transform log data from CSV format to JSON.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "dst": {
            "default": "decoded_csv",
            "description": "Destination key which will receive the parsed object.",
            "type": "string"
          },
          "header": {
            "default": "",
            "description": "Preset header",
            "type": "string"
          },
          "parseHeader": {
            "default": false,
            "type": "boolean"
          },
          "src": {
            "default": "log",
            "description": "Source key which contains raw CSV data.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "label": "Decode CSV",
      "uiSchema": {
        "labels": {
          "parseHeader": "Parse header"
        }
      }
    },
    "csv_encode": {
      "description": "Transform log data from JSON to CSV format.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "dst": {
            "default": "encoded_csv",
            "description": "Destination key which will receive the serialized CSV.",
            "type": "string"
          },
          "header": {
            "description": "Preset header for the generated CSV stream",
            "type": "string"
          },
          "src": {
            "description": "Source key which contains the object to be converted to CSV. If `header` is not set, this must be an array of strings.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "label": "Encode CSV",
      "uiSchema": {
        "labels": {
          "header": "Header"
        }
      }
    },
    "custom_script": {
      "description": "Write a custom Lua script to transform your telemetry data",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "script": {
            "default": "-- The function below has an API similar to that of fluent-bit Lua scripts.\n-- The main exception is the extra paramenter `code`, which contains the value\n-- returned by the previous processing rule.\n--\n-- See https://docs.fluentbit.io/manual/pipeline/filters/lua for details.\nreturn function(tag, ts, record, code)\n  -- Add statements before the \"return\" line.\n  -- You can access a certain field (\"field_a\" for example) in\n  -- using \"record.field_a\" or \"record['field_a']\".\n  --\n  -- Here's a simple example that concatenates \"key_one\" and \"key_two\" to\n  -- a new field named \"key_three\"\n  --\n  --    record.key_three = tostring(record.key_one) .. tostring(record.key_two)\n  return code, ts, record\nend\n",
            "description": "Lua script implemented similarly to fluent-bit Lua filters.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "label": "Custom Lua",
      "uiSchema": {
        "form": {
          "script": "code:lua"
        },
        "labels": {
          "script": "Lua script"
        }
      }
    },
    "deduplicate": {
      "description": "Look for any records that contain identical key/value data within a specified time frame, then remove all but the earliest of those records.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "description": "Key to use for deduplicating records",
            "type": "string"
          },
          "skipMissing": {
            "default": true,
            "description": "If the specified key is not found, don't touch the record",
            "type": "boolean"
          },
          "window": {
            "description": "Time window in seconds",
            "type": "integer"
          }
        },
        "required": [
          "window",
          "key"
        ],
        "type": "object"
      },
      "label": "Deduplicate records",
      "uiSchema": {
        "labels": {
          "key": "Source key",
          "skipMissing": "Ignore records without key",
          "window": "Time window"
        },
        "ordering": [
          "window",
          "key"
        ]
      }
    },
    "delete": {
      "description": "Delete a specified key and its associated value from every record that passes through your pipeline.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "description": "Key which will be deleted",
            "type": "string"
          }
        },
        "required": [
          "key"
        ],
        "type": "object"
      },
      "label": "Delete key"
    },
    "extract_kv": {
      "description": "Use a regular expression to search for key/value pairs inside a string, then create a structured objectto store those key/value pairs. Your regular expression must have two capture groups.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "dst": {
            "description": "Destination key which will contain the parsed object",
            "type": "string"
          },
          "regex": {
            "description": "Regular expression that will be used to extract keys/values. It must have two capture groups, which will be the key and value.",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          },
          "src": {
            "description": "Source key from which keys/values will be extracted from.",
            "type": "string"
          }
        },
        "required": [
          "dst",
          "src",
          "regex"
        ],
        "type": "object"
      },
      "label": "Extract keys/values"
    },
    "flatten": {
      "description": "Search for key/value pairs inside a JSON object, then either move or copy any applicable key/value pairs up one level into the specified object's parent object.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "keepOrig": {
            "default": false,
            "description": "If true, the flattened object will not be removed from the record.",
            "type": "boolean"
          },
          "key": {
            "description": "Key which contains the nested object to be merged.",
            "type": "string"
          },
          "keyReplacement": {
            "default": "%1",
            "description": "Replacement key",
            "type": "string"
          },
          "regex": {
            "default": "^.+$",
            "description": "Regular expression that will be used match keys that will be merged",
            "type": "string"
          }
        },
        "required": [
          "key"
        ],
        "type": "object"
      },
      "label": "Flatten subrecord",
      "uiSchema": {
        "labels": {
          "keepOrig": "Keep original object"
        }
      }
    },
    "hash": {
      "description": "Copy the value of a specified key, hash that value, then store the hashed copy in a specified destination key.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "algo": {
            "default": "sha256",
            "description": "Hash algorithm",
            "enum": [
              "sha256",
              "md5"
            ],
            "type": "string"
          },
          "dst": {
            "description": "Destination key which will contain the computed hash. Defaults to \"[SOURCE_KEY]_[HASH_ALGORITHM]\".",
            "type": "string"
          },
          "encoding": {
            "default": "hex",
            "description": "Encoding algorithm",
            "enum": [
              "hex",
              "binary",
              "base64"
            ],
            "type": "string"
          },
          "src": {
            "description": "Source key from which will be used to compute the hash",
            "type": "string"
          }
        },
        "required": [
          "src",
          "algo",
          "encoding"
        ],
        "type": "object"
      },
      "label": "Hash key",
      "uiSchema": {
        "labels": {
          "base64": "Base64",
          "binary": "Binary",
          "hex": "Hexadecimal",
          "md5": "MD5",
          "sha256": "SHA256"
        }
      }
    },
    "join": {
      "description": "Combine values from multiple records into an array of values within a single record.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "description": "Key which contains the nested array items in each split record.",
            "type": "string"
          },
          "skipMissing": {
            "default": false,
            "description": "Skip records where the specified key is missing",
            "type": "boolean"
          }
        },
        "required": [
          "key"
        ],
        "type": "object"
      },
      "label": "Join records",
      "uiSchema": {
        "labels": {
          "key": "Source Key"
        }
      }
    },
    "json_decode": {
      "description": "Transform an escaped JSON string into a structured JSON object.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "dst": {
            "default": "decoded_json",
            "description": "Destination key which will receive the parsed object.",
            "type": "string"
          },
          "src": {
            "default": "log",
            "description": "Source key which contains raw JSON data.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "label": "Decode JSON"
    },
    "json_encode": {
      "description": "Transform a JSON object into an escaped string.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "dst": {
            "default": "encoded_json",
            "description": "Destination key which will receive the serialized JSON.",
            "type": "string"
          },
          "src": {
            "description": "Source key which contains the object to be converted to JSON. If missing, the whole record will be serialized.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "label": "Encode JSON"
    },
    "lift": {
      "description": "Use regular expressions to search for key/value pairs inside a JSON object, then either move or copy any applicabledata out of the JSON object and into a higher level of the record.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "keepOrig": {
            "default": false,
            "description": "If true, the original key will not be removed from the parent.",
            "type": "boolean"
          },
          "key": {
            "description": "Key which contains the nested object to be merged.",
            "type": "string"
          },
          "keyReplacement": {
            "default": "%1",
            "description": "Replacement key",
            "type": "string"
          },
          "levels": {
            "default": 1,
            "description": "Levels",
            "type": "integer"
          },
          "regex": {
            "default": "^.+$",
            "description": "Regular expression that will be used match keys that will be merged",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          }
        },
        "required": [
          "key"
        ],
        "type": "object"
      },
      "label": "Lift submap",
      "uiSchema": {
        "labels": {
          "keepOrig": "Keep original"
        }
      }
    },
    "multiline_join": {
      "description": "Combine multiple logs into a single log by looking for repeating patterns in log data.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "lineLimit": {
            "default": 1000,
            "description": "Maximum lines.",
            "minimum": 2,
            "type": "integer"
          },
          "regex": {
            "description": "Regular expression to match the start of a new record.",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          },
          "src": {
            "default": "log",
            "description": "Source key from which lines will be joined.",
            "type": "string"
          }
        },
        "required": [
          "regex"
        ],
        "type": "object"
      },
      "label": "Multiline join"
    },
    "nest": {
      "description": "Move the value of a specified source key into an object nested under a specified destination key.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "dst": {
            "description": "Destination key which will receive the nested keys.",
            "type": "string"
          },
          "matchCase": {
            "default": false,
            "description": "Flag which controls if the regex match will be case-sensitive (regexMode only).",
            "type": "boolean"
          },
          "merge": {
            "default": false,
            "description": "If the destination map already exists, merge the nested keys.",
            "type": "boolean"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          },
          "regexMode": {
            "default": false,
            "description": "If set, `src` will be interpreted as a regex.",
            "type": "boolean"
          },
          "src": {
            "description": "Source keys which will be nested. If missing, the whole record will be nested.",
            "type": "string"
          }
        },
        "required": [
          "dst"
        ],
        "type": "object"
      },
      "label": "Nest keys",
      "uiSchema": {
        "labels": {
          "merge": "Merge"
        }
      }
    },
    "parse": {
      "description": "Use a regular expression to search for values inside a string and to assign a key to each value, then store those key/value pairs in a structured object.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "dst": {
            "description": "Destination key which will contain the parsed object",
            "type": "string"
          },
          "regex": {
            "description": "Regular expression that will be used to extract keys/values. It must have named capture groups.",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          },
          "src": {
            "description": "Source key from which keys/values will be extracted from.",
            "type": "string"
          }
        },
        "required": [
          "src",
          "dst"
        ],
        "type": "object"
      },
      "label": "Parse"
    },
    "parse_number": {
      "description": "Transform a value embedded in a string into a number, which you can then incorporate into numeric operations.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "base": {
            "default": 10,
            "description": "Numeric base",
            "type": "integer"
          },
          "key": {
            "description": "Key from which a number will be extracted.",
            "type": "string"
          },
          "regex": {
            "default": "[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)",
            "description": "Regular expression used to extract number from the value.",
            "type": "string"
          }
        },
        "required": [
          "key"
        ],
        "type": "object"
      },
      "label": "Parse number"
    },
    "put": {
      "description": "Add the same key/value pair to every record that passes through your pipeline.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "description": "Key which will be added/updated",
            "type": "string"
          },
          "value": {
            "description": "New value for the key",
            "type": "string"
          }
        },
        "required": [
          "key",
          "value"
        ],
        "type": "object"
      },
      "label": "Add/set key/value",
      "uiSchema": {
        "labels": {
          "value": "Value"
        },
        "ordering": [
          "key",
          "value"
        ]
      }
    },
    "redact": {
      "description": "Obscure all or part of a specified key's value by replacing the original string with a series of repeated characters.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "description": "Key which contains value to be redacted.",
            "type": "string"
          },
          "matchCase": {
            "default": false,
            "description": "Flag which controls if the regex match will be case-sensitive",
            "type": "boolean"
          },
          "regex": {
            "description": "Pattern within the value which will be redacted.",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          },
          "replaceChar": {
            "default": "*",
            "description": "Characters which will replace the value.",
            "type": "string"
          }
        },
        "required": [
          "key",
          "regex"
        ],
        "type": "object"
      },
      "label": "Redact/mask value",
      "uiSchema": {
        "labels": {
          "replaceChar": "Replacement"
        },
        "ordering": [
          "key",
          "regex",
          "replaceChar"
        ]
      }
    },
    "rename": {
      "description": "Change the name of a specified key.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "dst": {
            "description": "Destination key to which the value will be moved to. If `regexMode` is true, this can reference captured groups.",
            "type": "string"
          },
          "matchCase": {
            "default": false,
            "description": "Flag which controls if the regex match will be case-sensitive",
            "type": "boolean"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          },
          "regexMode": {
            "default": false,
            "description": "If set, `src` will be treated as a regex and `dst` as a substitution pattern.",
            "type": "boolean"
          },
          "src": {
            "description": "Source key from which the value will be moved from. If `regexMode` is true, this can match multiple keys.",
            "type": "string"
          }
        },
        "required": [
          "src",
          "dst"
        ],
        "type": "object"
      },
      "label": "Rename keys"
    },
    "replace": {
      "description": "Search for a string within the value of a key, then replace that string with a new specified set of characters.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "description": "Key which contains value to be replaced.",
            "type": "string"
          },
          "matchCase": {
            "default": false,
            "description": "Flag which controls if the regex match will be case-sensitive",
            "type": "boolean"
          },
          "regex": {
            "description": "Pattern within the value which will be replaced.",
            "type": "string"
          },
          "regexEngine": {
            "default": "pcre2",
            "description": "Regular expression engine to use",
            "enum": [
              "pcre2",
              "onig",
              "posix",
              "tre",
              "gnu"
            ],
            "type": "string"
          },
          "replacement": {
            "description": "Replacement pattern. Can reference capture groups in the `regex`.",
            "type": "string"
          },
          "submax": {
            "description": "Maximum number of substitutions",
            "type": "integer"
          }
        },
        "required": [
          "key",
          "regex",
          "replacement"
        ],
        "type": "object"
      },
      "label": "Search/replace value",
      "uiSchema": {
        "labels": {
          "replacement": "Replacement value"
        },
        "ordering": [
          "key",
          "regex",
          "matchCase",
          "submax"
        ]
      }
    },
    "sampling": {
      "description": "Preserve a percentage of records that pass through your pipeline and discard the rest.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "percentage": {
            "description": "Percentage of records to be flushed",
            "maximum": 100,
            "minimum": 1,
            "type": "integer"
          },
          "seed": {
            "description": "Seed for random number generator",
            "type": "integer"
          },
          "window": {
            "description": "Time window in seconds",
            "type": "integer"
          }
        },
        "required": [
          "window",
          "percentage"
        ],
        "type": "object"
      },
      "label": "Random sampling",
      "uiSchema": {
        "labels": {
          "percentage": "Sample %",
          "window": "Time window in seconds"
        },
        "ordering": [
          "window",
          "percentage"
        ]
      }
    },
    "split": {
      "description": "Split an array of records into multiple standalone records.",
      "jsonSchema": {
        "additionalProperties": false,
        "properties": {
          "dest": {
            "default": "",
            "description": "Destination key to contain the array item. If empty, defaults to \"key\"",
            "type": "string"
          },
          "keepOrig": {
            "default": false,
            "description": "Keep \"key\" when it is different than \"dest\"",
            "type": "boolean"
          },
          "key": {
            "description": "Key which contains the nested array.",
            "type": "string"
          },
          "skipEmpty": {
            "default": false,
            "description": "If the specified key is an empty array, don't touch the record",
            "type": "boolean"
          },
          "skipMissing": {
            "default": false,
            "description": "If the specified key is not an array, don't touch the record",
            "type": "boolean"
          }
        },
        "required": [
          "key"
        ],
        "type": "object"
      },
      "label": "Split record",
      "uiSchema": {
        "labels": {
          "dest": "Destination key",
          "keepOrig": "Preserve original array",
          "key": "Source Key",
          "skipEmpty": "Preserve empty arrays",
          "skipMissing": "Preserve non-array data"
        }
      }
    }
  },
  "uiSchemaFallback": {
    "errors": {
      "should be integer": "Should be an integer"
    },
    "labels": {
      "dst": "Destination key",
      "gnu": "GNU",
      "key": "Key",
      "matchCase": "Match case",
      "onig": "Oniguruma",
      "pcre2": "PCRE2",
      "posix": "POSIX",
      "regex": "Regex",
      "regexEngine": "Regex engine",
      "regexExtended": "Extended regex syntax",
      "regexMode": "Regex mode",
      "src": "Source key",
      "tre": "TRE"
    },
    "ordering": [
      "src",
      "dst",
      "key",
      "regex",
      "matchCase",
      "regexEngine",
      "regexExtended"
    ]
  },
  "version": "v0.1-dev"
}
